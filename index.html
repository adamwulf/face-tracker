<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracker - Webcam Face Detection</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-bottom: 10px;
            text-align: center;
        }

        .github-link {
            text-align: center;
            margin-bottom: 20px;
        }

        .github-link a {
            color: #4CAF50;
            text-decoration: none;
            font-size: 14px;
        }

        .github-link a:hover {
            text-decoration: underline;
        }

        .main-display {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        #video {
            display: block;
            width: 80px;
            height: 60px;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }
        
        .feature-toggle {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .feature-toggle label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            transform: scale(1.2);
        }
        
        .cartoon-container {
            text-align: center;
            position: relative;
        }

        .cartoon-wrapper {
            position: relative;
            display: inline-block;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            width: 800px;
            height: 500px;
            background: rgb(0, 255, 0);
        }

        .cartoon-wrapper img {
            position: absolute;
            display: block;
        }

        #cartoon-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 800px;
            height: 500px;
        }
        
        .animation-controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-container label {
            font-size: 14px;
            min-width: 80px;
        }

        input[type="range"] {
            width: 100px;
        }

        .face-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            max-width: 600px;
        }

        .face-button {
            width: 40px;
            height: 40px;
            padding: 0;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            background: #222;
            overflow: hidden;
            transition: all 0.2s;
        }

        .face-button:hover {
            border-color: #4CAF50;
            transform: scale(1.1);
        }

        .face-button.active {
            border-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .face-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        /* Prevent Dark Reader from modifying stroke colors */
        [stroke] {
            --darkreader-inline-stroke: #333 !important;
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 24px;
            }

            .main-display {
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            .container {
                /* Keep camera overlay on top-left of cartoon */
                top: 10px;
                left: 10px;
                width: auto;
            }

            #video {
                width: 100px;
                height: 75px;
            }

            .cartoon-container {
                width: 100%;
                margin-top: 0;
            }

            .cartoon-wrapper {
                width: 100% !important;
                max-width: calc(100vw - 20px) !important; /* Account for body padding */
                height: auto !important;
                aspect-ratio: 8/5;
            }

            .cartoon-wrapper img {
                /* Ensure background image scales from top-left like SVG */
                transform-origin: top left;
            }

            #cartoon-svg {
                width: 100% !important;
                height: 100% !important;
            }

            .controls {
                flex-direction: column;
                width: 100%;
            }

            button {
                width: 100%;
                max-width: 300px;
            }

            .feature-toggle {
                flex-wrap: wrap;
                justify-content: center;
            }

            .animation-controls {
                flex-direction: column;
                width: 100%;
                gap: 10px;
            }

            .slider-container {
                width: 100%;
                max-width: 300px;
            }

            .slider-container label {
                min-width: 120px;
            }

            input[type="range"] {
                flex: 1;
            }

            .face-buttons {
                max-width: 100%;
            }
        }

        /* Extra small devices */
        @media (max-width: 480px) {
            h1 {
                font-size: 20px;
            }

            .slider-container {
                flex-direction: column;
                align-items: flex-start;
            }

            .slider-container label {
                font-size: 12px;
            }

            input[type="range"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>üé≠ Face Tracker</h1>
    <div class="github-link">
        <a href="https://github.com/adamwulf/face-tracker" target="_blank">View on Github</a>
    </div>

    <div class="main-display">
        <div class="cartoon-container">
            <div class="container">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="canvas"></canvas>
            </div>
            <div class="cartoon-wrapper" id="cartoon-wrapper">
            <img id="cartoon-bg" src="facecam-blank.png" alt="Cartoon Face Background">
            <svg id="cartoon-svg" width="800" height="500" viewBox="0 0 800 500">
                <!-- Debug Layer - Bounding boxes -->
                <g id="debug-layer">
                    <!-- Will show target frame and original bounding box -->
                </g>

                <!-- Eyes Layer - Custom eye images -->
                <g id="eyes-layer">
                    <image id="left-eye" href="eye-left.png" x="0" y="0" width="30" height="30" style="transform-origin: center;"/>
                    <image id="right-eye" href="eye-right.png" x="0" y="0" width="30" height="30" style="transform-origin: center;"/>
                </g>

                <!-- Mouth Layer - Will use the same mesh as camera overlay -->
                <g id="mouth-layer">
                    <!-- This will be populated with the same mouth landmarks as the camera -->
                    <image id="smile-image" href="default-smile.png" x="0" y="0" width="80" height="80" style="display: none;"/>
                </g>
            </svg>
        </div>

        <!-- Face selection buttons -->
        <div class="face-buttons" id="face-buttons">
            <!-- Face buttons will be populated here -->
        </div>
        </div>
    </div>

    <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
        <button id="toggleDebug">Toggle Debug</button>
    </div>

    <div class="feature-toggle">
        <label>
            <input type="checkbox" id="showEyes" checked>
            üëÅÔ∏è Eyes
        </label>
        <label>
            <input type="checkbox" id="showMouth" checked>
            üëÑ Mouth
        </label>
        <label>
            <input type="checkbox" id="showNose" checked>
            üëÉ Nose
        </label>
        <label>
            <input type="checkbox" id="showEars" checked>
            üëÇ Ears
        </label>
    </div>
    
    <div class="animation-controls">
        <div class="slider-container">
            <label>Animation Intensity:</label>
            <input type="range" id="animationIntensity" min="0" max="2" step="0.1" value="1">
            <span id="intensityValue">1.0</span>
        </div>
        <div class="slider-container">
            <label>Eye Sensitivity:</label>
            <input type="range" id="eyeSensitivity" min="0" max="3" step="0.1" value="1">
            <span id="eyeValue">1.0</span>
        </div>
        <div class="slider-container">
            <label>Mouth Sensitivity:</label>
            <input type="range" id="mouthSensitivity" min="0" max="3" step="0.1" value="1">
            <span id="mouthValue">1.0</span>
        </div>
        <div class="slider-container">
            <label>Head Rotation:</label>
            <input type="range" id="headRotation" min="0" max="2" step="0.1" value="1">
            <span id="headValue">1.0</span>
        </div>
        <div class="slider-container">
            <label>Blink Frequency:</label>
            <input type="range" id="blinkFrequency" min="0" max="3" step="0.1" value="1">
            <span id="blinkValue">1.0</span>
        </div>
    </div>
    
    <div class="status" id="status">Click "Start Camera" to begin face tracking</div>
    <div class="status" id="debug-yaw" style="margin-top: 10px;">Yaw: 0</div>

    <!-- Preload face images (hidden) -->
    <div id="face-preload" style="display: none;">
        <img id="face-blank" src="facecam-blank.png" alt="Blank Face">
        <img id="face-1" src="faces/facecam-1.png" alt="Face 1">
        <img id="face-2" src="faces/facecam-2.png" alt="Face 2">
        <img id="face-3" src="faces/facecam-3.png" alt="Face 3">
        <img id="face-4" src="faces/facecam-4.png" alt="Face 4">
        <img id="face-5" src="faces/facecam-5.png" alt="Face 5">
        <img id="face-6" src="faces/facecam-6.png" alt="Face 6">
        <img id="face-7" src="faces/facecam-7.png" alt="Face 7">
        <img id="face-8" src="faces/facecam-8.png" alt="Face 8">
        <img id="face-9" src="faces/facecam-9.png" alt="Face 9">
        <img id="face-10" src="faces/facecam-10.png" alt="Face 10">
        <img id="face-11" src="faces/facecam-11.png" alt="Face 11">
        <img id="face-12" src="faces/facecam-12.png" alt="Face 12">
        <img id="face-13" src="faces/facecam-13.png" alt="Face 13">
        <img id="face-14" src="faces/facecam-14.png" alt="Face 14">
        <img id="face-15" src="faces/facecam-15.png" alt="Face 15">
        <img id="face-16" src="faces/facecam-16.png" alt="Face 16">
        <img id="face-17" src="faces/facecam-17.png" alt="Face 17">
        <img id="face-18" src="faces/facecam-18.png" alt="Face 18">
        <img id="face-19" src="faces/facecam-19.png" alt="Face 19">
        <img id="face-20" src="faces/facecam-20.png" alt="Face 20">
    </div>

    <!-- MediaPipe Face Mesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    
    <script>
        class FaceTracker {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.faceMesh = null;
                this.isRunning = false;

                // Face configuration
                this.faceConfigs = [];
                this.currentFaceIndex = 0;

                // Track last 5 random faces for variety
                this.recentRandomFaces = [];

                // Debug mode
                this.showDebug = false;

                // Cartoon animation properties
                this.cartoonElements = {
                    leftEye: document.getElementById('left-eye'),
                    rightEye: document.getElementById('right-eye'),
                    mouthLayer: document.getElementById('mouth-layer'),
                    debugLayer: document.getElementById('debug-layer'),
                    smileImage: document.getElementById('smile-image'),
                    background: document.getElementById('cartoon-bg')
                };

                // Animation smoothing
                this.smoothingFactor = 0.3;
                this.lastPositions = {};

                // Mouth closed timer for smile display
                this.mouthClosedTimer = {
                    closedStartTime: null,
                    isShowingSmile: false
                };
                this.mouthClosedDelay = 500; // milliseconds

                // Original PNG dimensions and rendered size
                const originalPngWidth = 310;
                const originalPngHeight = 258;
                const renderedSize = 400; // Square container

                // Calculate scaling for object-fit: cover
                // The image maintains aspect ratio and covers the container
                const scaleX = renderedSize / originalPngWidth;
                const scaleY = renderedSize / originalPngHeight;
                const scale = Math.max(scaleX, scaleY); // Use larger scale to "cover"

                // Calculate actual rendered image dimensions
                const renderedImageWidth = originalPngWidth * scale;
                const renderedImageHeight = originalPngHeight * scale;

                // Calculate offset due to centering (object-fit: cover centers the image)
                const offsetX = (renderedImageWidth - renderedSize) / 2;
                const offsetY = (renderedImageHeight - renderedSize) / 2;

                // Target frame coordinates in original PNG (provided by user)
                const originalTargetFrame = {
                    x: 110,
                    y: 80,
                    width: 110,
                    height: 105
                };

                // Scale target frame to rendered size and adjust for offset
                this.targetFrame = {
                    x: originalTargetFrame.x * scale - offsetX + 8,
                    y: originalTargetFrame.y * scale - offsetY,
                    width: originalTargetFrame.width * scale,
                    height: originalTargetFrame.height * scale
                };

                // Store scale factor for smile image
                this.imageScale = scale;

                // Blinking system - both eyes blink together
                this.blinkImages = ['eye-blink-1.png', 'eye-blink-2.png'];
                this.blinkTimer = {
                    nextBlink: 0,
                    isBlinking: false,
                    blinkStart: 0
                };
                this.blinkDuration = 150; // milliseconds
                this.minBlinkInterval = 2000; // minimum 2 seconds between blinks
                this.maxBlinkInterval = 5000; // maximum 5 seconds between blinks

                // Initialize faces analysis
                this.initializeFaces();

                this.setupEventListeners();
                this.setupMediaPipe();
            }

            async initializeFaces() {
                console.log('Analyzing all face images...');
                document.getElementById('status').textContent = 'Analyzing face images...';

                // Wait a moment for images to attempt loading
                await new Promise(resolve => setTimeout(resolve, 500));

                // Check which preloaded images successfully loaded and analyze them
                const blankImg = document.getElementById('face-blank');
                if (blankImg.complete && blankImg.naturalWidth > 0) {
                    this.analyzeImageElement(blankImg, 'facecam-blank.png', 'blank', 'Blank Face');
                }

                // Check numbered faces
                for (let i = 1; i <= 20; i++) {
                    const img = document.getElementById(`face-${i}`);
                    if (img && img.complete && img.naturalWidth > 0) {
                        this.analyzeImageElement(img, `faces/facecam-${i}.png`, `face-${i}`, `Face ${i}`);
                    }
                }

                // Calculate alignment offsets relative to first face (reference)
                if (this.faceConfigs.length > 0) {
                    const reference = this.faceConfigs[0];
                    console.log(`\nAligning all faces to reference: ${reference.name}`);
                    console.log(`Reference body bottom: ${reference.bodyBottom}`);

                    for (const face of this.faceConfigs) {
                        // Calculate alignment offset (vertical shift to align bottom)
                        // Positive offset = shift UP, Negative offset = shift DOWN
                        face.alignmentOffset = face.bodyBottom - reference.bodyBottom;
                        console.log(`${face.name}: bodyBottom=${face.bodyBottom}, offset = ${face.alignmentOffset}px`);
                    }
                }

                console.log(`Face analysis complete! Found ${this.faceConfigs.length} faces.`);
                document.getElementById('status').textContent = `Face analysis complete! Found ${this.faceConfigs.length} faces. Click "Start Camera" to begin`;

                // Populate face buttons
                this.populateFaceButtons();

                // Load the first non-blank face
                const firstFaceIndex = this.faceConfigs.findIndex(face => face.id !== 'blank');
                if (firstFaceIndex !== -1) {
                    this.changeFace(firstFaceIndex);
                    console.log(`Auto-selected first face: ${this.faceConfigs[firstFaceIndex].name}`);
                }
            }

            populateFaceButtons() {
                const container = document.getElementById('face-buttons');
                container.innerHTML = '';

                this.faceConfigs.forEach((face, index) => {
                    // Skip the blank face - it's only used as a reference for alignment
                    if (face.id === 'blank') return;

                    const button = document.createElement('button');
                    button.className = 'face-button';
                    button.dataset.faceIndex = index;
                    button.title = face.name;

                    const img = document.createElement('img');
                    img.src = face.image;
                    img.alt = face.name;

                    button.appendChild(img);
                    button.addEventListener('click', () => this.changeFace(index));

                    container.appendChild(button);
                });

                // Add random face button at the end
                const randomButton = document.createElement('button');
                randomButton.className = 'face-button';
                randomButton.id = 'randomFace';
                randomButton.title = 'Random Face';
                randomButton.style.fontSize = '24px';
                randomButton.style.display = 'flex';
                randomButton.style.alignItems = 'center';
                randomButton.style.justifyContent = 'center';
                randomButton.textContent = 'üîÑ';
                randomButton.addEventListener('click', () => this.randomizeFace());

                container.appendChild(randomButton);
            }

            changeFace(index) {
                if (index < 0 || index >= this.faceConfigs.length) {
                    console.error('Invalid face index:', index);
                    return;
                }

                this.currentFaceIndex = index;
                const face = this.faceConfigs[index];

                console.log(`Changing to ${face.name}`);

                // Get reference face (first face) for alignment
                const reference = this.faceConfigs[0];

                // Calculate scale factor based on anchor point distances
                const referenceAnchorWidth = reference.rightAnchor[0] - reference.leftAnchor[0];
                const faceAnchorWidth = face.rightAnchor[0] - face.leftAnchor[0];
                const scale = referenceAnchorWidth / faceAnchorWidth;

                // Calculate scaled dimensions
                const scaledWidth = face.width * scale;
                const scaledHeight = face.height * scale;
                const scaledBodyBottom = face.bodyBottom * scale;
                const scaledLeftAnchorX = face.leftAnchor[0] * scale;

                // Calculate where the bodyBottom line should be in canvas coordinates
                const CANVAS_WIDTH = 800;
                const CANVAS_HEIGHT = 500;
                // Position reference face flush with bottom - the bodyBottom line accounts for
                // pixels below it, so we position it at CANVAS_HEIGHT
                const targetBodyBottomY = CANVAS_HEIGHT - (reference.height - reference.bodyBottom);

                // Position this face so its bodyBottom aligns with targetBodyBottomY
                const faceTop = targetBodyBottomY - scaledBodyBottom;

                // Calculate reference position for horizontal alignment
                const referenceLeft = (CANVAS_WIDTH - reference.width) / 2;
                const targetLeftAnchorX = referenceLeft + reference.leftAnchor[0];

                // Position horizontally so left anchor aligns
                const faceLeft = targetLeftAnchorX - scaledLeftAnchorX;

                // Calculate percentage-based positions for responsive scaling
                const leftPercent = (faceLeft / CANVAS_WIDTH) * 100;
                const topPercent = (faceTop / CANVAS_HEIGHT) * 100;
                const widthPercent = (scaledWidth / CANVAS_WIDTH) * 100;
                const heightPercent = (scaledHeight / CANVAS_HEIGHT) * 100;

                // Update the background image and position using percentages
                this.cartoonElements.background.src = face.image;
                this.cartoonElements.background.style.width = `${widthPercent}%`;
                this.cartoonElements.background.style.height = `${heightPercent}%`;
                this.cartoonElements.background.style.left = `${leftPercent}%`;
                this.cartoonElements.background.style.top = `${topPercent}%`;
                this.cartoonElements.background.style.transform = 'none';
                // Reset any flip state
                this.cartoonElements.background.dataset.flipped = 'false';

                console.log(`Positioning: left=${leftPercent}%, top=${topPercent}%, size=${widthPercent}%x${heightPercent}%, scale=${scale.toFixed(3)}`);

                // Update active button styling
                document.querySelectorAll('.face-button').forEach((btn, i) => {
                    if (i === index) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // Store face position and scale for animation calculations
                this.faceLeft = faceLeft;
                this.faceTop = faceTop;
                this.faceScale = scale;
                this.scaledWidth = scaledWidth;
                this.scaledHeight = scaledHeight;

                // Draw debug visualization
                this.drawAlignmentDebug(face, reference, faceLeft, faceTop, scale, scaledWidth, scaledHeight);

                // Recalculate target frame based on this face's dimensions
                this.updateTargetFrame(face);
            }

            toggleDebug() {
                this.showDebug = !this.showDebug;
                if (this.showDebug) {
                    // Redraw debug for current face
                    if (this.faceConfigs.length > 0) {
                        const face = this.faceConfigs[this.currentFaceIndex];
                        const reference = this.faceConfigs[0];
                        this.drawAlignmentDebug(face, reference, this.faceLeft, this.faceTop, this.faceScale, this.scaledWidth, this.scaledHeight);
                    }
                } else {
                    // Clear debug layer
                    this.cartoonElements.debugLayer.innerHTML = '';
                }
            }

            randomizeFace() {
                // Get all non-blank face indices
                const nonBlankIndices = this.faceConfigs
                    .map((face, index) => ({ face, index }))
                    .filter(item => item.face.id !== 'blank')
                    .map(item => item.index);

                if (nonBlankIndices.length <= 1) {
                    console.log('Not enough faces to randomize');
                    return;
                }

                // Filter out the current face and recent faces (if we have more than 5 faces)
                let availableIndices = nonBlankIndices.filter(index => index !== this.currentFaceIndex);

                if (nonBlankIndices.length > 5) {
                    // Only exclude recent faces if we have more than 5 total faces
                    availableIndices = availableIndices.filter(index => !this.recentRandomFaces.includes(index));
                }

                // If we've filtered out everything, reset and use all faces except current
                if (availableIndices.length === 0) {
                    availableIndices = nonBlankIndices.filter(index => index !== this.currentFaceIndex);
                }

                // Pick a random face from the available ones
                const randomIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];

                // Update recent faces list (keep last 5)
                this.recentRandomFaces.push(randomIndex);
                if (this.recentRandomFaces.length > 5) {
                    this.recentRandomFaces.shift(); // Remove oldest
                }

                // Change to the random face
                this.changeFace(randomIndex);
                console.log(`Randomized to: ${this.faceConfigs[randomIndex].name}, recent: [${this.recentRandomFaces.map(i => this.faceConfigs[i].name).join(', ')}]`);
            }

            drawAlignmentDebug(face, reference, faceLeft, faceTop, scale, scaledWidth, scaledHeight) {
                // Clear previous debug visualization
                this.cartoonElements.debugLayer.innerHTML = '';

                // Only draw if debug mode is on
                if (!this.showDebug) return;

                // Draw bounding box for the current face image (scaled)
                const imageBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                imageBox.setAttribute('x', faceLeft);
                imageBox.setAttribute('y', faceTop);
                imageBox.setAttribute('width', scaledWidth);
                imageBox.setAttribute('height', scaledHeight);
                imageBox.setAttribute('fill', 'none');
                imageBox.setAttribute('stroke', 'yellow');
                imageBox.setAttribute('stroke-width', '2');
                imageBox.setAttribute('stroke-dasharray', '5,5');
                this.cartoonElements.debugLayer.appendChild(imageBox);

                // Draw RED dots for current face's anchor points (scaled)
                const leftAnchorX = faceLeft + face.leftAnchor[0] * scale;
                const leftAnchorY = faceTop + face.leftAnchor[1] * scale;
                const rightAnchorX = faceLeft + face.rightAnchor[0] * scale;
                const rightAnchorY = faceTop + face.rightAnchor[1] * scale;

                const leftDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                leftDot.setAttribute('cx', leftAnchorX);
                leftDot.setAttribute('cy', leftAnchorY);
                leftDot.setAttribute('r', '5');
                leftDot.setAttribute('fill', 'red');
                leftDot.setAttribute('stroke', 'white');
                leftDot.setAttribute('stroke-width', '1');
                this.cartoonElements.debugLayer.appendChild(leftDot);

                const rightDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                rightDot.setAttribute('cx', rightAnchorX);
                rightDot.setAttribute('cy', rightAnchorY);
                rightDot.setAttribute('r', '5');
                rightDot.setAttribute('fill', 'red');
                rightDot.setAttribute('stroke', 'white');
                rightDot.setAttribute('stroke-width', '1');
                this.cartoonElements.debugLayer.appendChild(rightDot);

                // Draw BLUE dots for reference face's anchor points (where current face should align to)
                // Calculate where the reference face would be positioned
                const CANVAS_WIDTH = 800;
                const CANVAS_HEIGHT = 500;
                const referenceBottomY = CANVAS_HEIGHT - (reference.height - reference.bodyBottom);
                const referenceTop = referenceBottomY - reference.height;
                const referenceLeft = (CANVAS_WIDTH - reference.width) / 2;

                const refLeftAnchorX = referenceLeft + reference.leftAnchor[0];
                const refLeftAnchorY = referenceTop + reference.leftAnchor[1];
                const refRightAnchorX = referenceLeft + reference.rightAnchor[0];
                const refRightAnchorY = referenceTop + reference.rightAnchor[1];

                const refLeftDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                refLeftDot.setAttribute('cx', refLeftAnchorX);
                refLeftDot.setAttribute('cy', refLeftAnchorY);
                refLeftDot.setAttribute('r', '5');
                refLeftDot.setAttribute('fill', 'blue');
                refLeftDot.setAttribute('stroke', 'white');
                refLeftDot.setAttribute('stroke-width', '1');
                this.cartoonElements.debugLayer.appendChild(refLeftDot);

                const refRightDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                refRightDot.setAttribute('cx', refRightAnchorX);
                refRightDot.setAttribute('cy', refRightAnchorY);
                refRightDot.setAttribute('r', '5');
                refRightDot.setAttribute('fill', 'blue');
                refRightDot.setAttribute('stroke', 'white');
                refRightDot.setAttribute('stroke-width', '1');
                this.cartoonElements.debugLayer.appendChild(refRightDot);

                // Draw target frame (CYAN) - same for all faces since they're aligned and scaled
                const refBodyBottomY = referenceTop + reference.bodyBottom;
                const refTargetY = refBodyBottomY - reference.targetFrame.yTop_fromBodyBottom;
                const refTargetFrame = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                refTargetFrame.setAttribute('x', referenceLeft + reference.targetFrame.x);
                refTargetFrame.setAttribute('y', refTargetY);
                refTargetFrame.setAttribute('width', reference.targetFrame.width);
                refTargetFrame.setAttribute('height', reference.targetFrame.height);
                refTargetFrame.setAttribute('fill', 'none');
                refTargetFrame.setAttribute('stroke', 'cyan');
                refTargetFrame.setAttribute('stroke-width', '2');
                refTargetFrame.setAttribute('stroke-dasharray', '5,5');
                this.cartoonElements.debugLayer.appendChild(refTargetFrame);

                console.log(`Current face anchors (red): (${leftAnchorX},${leftAnchorY}) - (${rightAnchorX},${rightAnchorY})`);
                console.log(`Reference anchors (blue): (${refLeftAnchorX},${refLeftAnchorY}) - (${refRightAnchorX},${refRightAnchorY})`);
                console.log(`Target frame (cyan): (${referenceLeft + reference.targetFrame.x},${refTargetY})`);
            }

            updateTargetFrame(face) {
                // Since all faces are aligned AND scaled to match the reference,
                // the target frame is ALWAYS at the same canvas coordinates!
                // Just use the reference face's target frame.
                const reference = this.faceConfigs[0];

                // Calculate reference position
                const CANVAS_WIDTH = 800;
                const CANVAS_HEIGHT = 500;
                const targetBodyBottomY = CANVAS_HEIGHT - (reference.height - reference.bodyBottom);
                const refTop = targetBodyBottomY - reference.bodyBottom;
                const refLeft = (CANVAS_WIDTH - reference.width) / 2;

                // Target frame is always at the same position
                const refBodyBottomY = refTop + reference.bodyBottom;
                const targetFrameY = refBodyBottomY - reference.targetFrame.yTop_fromBodyBottom;

                this.targetFrame = {
                    x: refLeft + reference.targetFrame.x,
                    y: targetFrameY,
                    width: reference.targetFrame.width,
                    height: reference.targetFrame.height
                };

                // Smile image exists in SVG coordinate space (800x500 viewBox)
                // It should be constant size regardless of which background face is showing
                // Background images scale with percentages, but SVG uses fixed coordinates
                this.imageScale = 1.0;

                console.log('Target frame (constant for all faces):', this.targetFrame);
                console.log('Image scale for smile (constant):', this.imageScale);
            }

            analyzeImageElement(img, imagePath, faceId, faceName) {
                const width = img.naturalWidth;
                const height = img.naturalHeight;

                // Create temporary canvas to analyze pixels
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, width, height);
                const anchors = this.findBottomDarkPixels(imageData, width, height);

                // Define target frame with absolute coordinates from bodyBottom line
                // This ensures perfect alignment when faces are aligned at bodyBottom
                const targetFrameTopLeft = {
                    x: 110,
                    y: 80,
                    width: 110,
                    height: 105
                };

                // Calculate Y coordinates relative to bodyBottom (positive = above bodyBottom)
                const targetFrameTop_fromBodyBottom = anchors.bodyBottom - targetFrameTopLeft.y;
                const targetFrameBottom_fromBodyBottom = anchors.bodyBottom - (targetFrameTopLeft.y + targetFrameTopLeft.height);

                console.log(`${faceId} targetFrame: top=${targetFrameTop_fromBodyBottom}px above bodyBottom, bottom=${targetFrameBottom_fromBodyBottom}px above bodyBottom`);

                this.faceConfigs.push({
                    id: faceId,
                    name: faceName,
                    image: imagePath,
                    width: width,
                    height: height,
                    bodyBottom: anchors.bodyBottom,
                    leftAnchor: [anchors.leftX, anchors.leftY],
                    rightAnchor: [anchors.rightX, anchors.rightY],
                    targetFrame: {
                        x: targetFrameTopLeft.x,
                        yTop_fromBodyBottom: targetFrameTop_fromBodyBottom,  // Pixels above bodyBottom to target frame top
                        width: targetFrameTopLeft.width,
                        height: targetFrameTopLeft.height
                    }
                });

                console.log(`Analyzed ${faceId}:`, {
                    size: `${width}x${height}`,
                    bodyBottom: anchors.bodyBottom,
                    leftAnchor: [anchors.leftX, anchors.leftY],
                    rightAnchor: [anchors.rightX, anchors.rightY]
                });
            }

            findBottomDarkPixels(imageData, width, height, darknessThreshold = 100) {
                const data = imageData.data;

                let leftX = null, leftY = null;
                let rightX = null, rightY = null;
                let bodyBottom = null;

                // Search from bottom up
                for (let y = height - 1; y >= 0; y--) {
                    // Check left third for dark pixels
                    if (leftY === null) {
                        for (let x = 0; x < width / 3; x++) {
                            const idx = (y * width + x) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            const brightness = (r + g + b) / 3;

                            if (brightness < darknessThreshold) {
                                leftX = x;
                                leftY = y;
                                if (bodyBottom === null) bodyBottom = y;
                                break;
                            }
                        }
                    }

                    // Check right third for dark pixels
                    if (rightY === null) {
                        for (let x = width - 1; x >= (2 * width) / 3; x--) {
                            const idx = (y * width + x) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            const brightness = (r + g + b) / 3;

                            if (brightness < darknessThreshold) {
                                rightX = x;
                                rightY = y;
                                if (bodyBottom === null) bodyBottom = y;
                                break;
                            }
                        }
                    }

                    // Stop once we've found both
                    if (leftY !== null && rightY !== null) {
                        break;
                    }
                }

                return {
                    leftX: leftX ?? 0,
                    leftY: leftY ?? height - 1,
                    rightX: rightX ?? width - 1,
                    rightY: rightY ?? height - 1,
                    bodyBottom: bodyBottom ?? height - 1
                };
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('toggleDebug').addEventListener('click', () => this.toggleDebug());

                // Feature toggles
                ['showEyes', 'showMouth', 'showNose', 'showEars'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.updateSettings());
                });

                // Animation controls
                document.getElementById('animationIntensity').addEventListener('input', (e) => {
                    document.getElementById('intensityValue').textContent = e.target.value;
                });
                document.getElementById('eyeSensitivity').addEventListener('input', (e) => {
                    document.getElementById('eyeValue').textContent = e.target.value;
                });
                document.getElementById('mouthSensitivity').addEventListener('input', (e) => {
                    document.getElementById('mouthValue').textContent = e.target.value;
                });
                document.getElementById('headRotation').addEventListener('input', (e) => {
                    document.getElementById('headValue').textContent = e.target.value;
                });
                document.getElementById('blinkFrequency').addEventListener('input', (e) => {
                    document.getElementById('blinkValue').textContent = e.target.value;
                    this.updateBlinkFrequency(parseFloat(e.target.value));
                });
            }
            
            async setupMediaPipe() {
                this.faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });
                
                this.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.faceMesh.onResults((results) => this.onResults(results));
            }
            
            async start() {
                try {
                    // Request front-facing camera explicitly for mobile compatibility
                    const constraints = {
                        video: {
                            facingMode: 'user', // Front camera
                            width: { ideal: 640 },
                            height: { ideal: 480 }
                        }
                    };

                    console.log('Requesting camera with constraints:', constraints);
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);

                    this.video.srcObject = stream;

                    // Wait for video metadata to load to get actual dimensions
                    await new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            console.log('Video dimensions:', this.video.videoWidth, 'x', this.video.videoHeight);
                            resolve();
                        };
                    });

                    this.isRunning = true;

                    // Update button states
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('status').textContent = 'Camera started - detecting faces...';

                    // Start processing
                    this.processFrame();

                } catch (error) {
                    console.error('Error accessing camera:', error);
                    document.getElementById('status').textContent = 'Error: Could not access camera - ' + error.message;
                }
            }
            
            stop() {
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                
                this.isRunning = false;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update button states
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'Camera stopped';
            }
            
            async processFrame() {
                if (!this.isRunning) return;
                
                if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                    await this.faceMesh.send({ image: this.video });
                }
                
                requestAnimationFrame(() => this.processFrame());
            }
            
            onResults(results) {
                // Set canvas size to match video
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;

                // Debug logging
                if (!this.loggedCanvasSize) {
                    console.log('Canvas size set to:', this.canvas.width, 'x', this.canvas.height);
                    this.loggedCanvasSize = true;
                }

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    // Log first detection
                    if (!this.loggedFirstDetection) {
                        console.log('First face detected! Landmarks:', results.multiFaceLandmarks[0].length);
                        console.log('Sample landmark (nose tip):', results.multiFaceLandmarks[0][1]);
                        this.loggedFirstDetection = true;
                    }

                    results.multiFaceLandmarks.forEach(landmarks => {
                        this.drawFaceFeatures(landmarks);
                        this.animateCartoon(landmarks); // Add cartoon animation
                    });

                    document.getElementById('status').textContent =
                        `Detected ${results.multiFaceLandmarks.length} face(s) - Cartoon animated!`;
                } else {
                    document.getElementById('status').textContent = 'No faces detected';
                }
            }
            
            drawFaceFeatures(landmarks) {
                // MediaPipe Face Mesh provides 468 facial landmarks
                // Convert normalized coordinates to canvas coordinates
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                
                // Draw facial features based on toggles using actual landmark positions
                this.drawEyes(landmarks, canvasWidth, canvasHeight);
                this.drawMouth(landmarks, canvasWidth, canvasHeight);
                this.drawNose(landmarks, canvasWidth, canvasHeight);
                this.drawEars(landmarks, canvasWidth, canvasHeight);
            }
            
            drawEyes(landmarks, canvasWidth, canvasHeight) {
                if (!document.getElementById('showEyes').checked) return;
                
                // MediaPipe eye landmarks
                // Left eye: 33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246
                // Right eye: 362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398
                
                const leftEyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
                const rightEyeIndices = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 3;
                
                // Draw left eye
                this.ctx.beginPath();
                leftEyeIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw right eye
                this.ctx.beginPath();
                rightEyeIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.closePath();
                this.ctx.stroke();
            }
            
            drawMouth(landmarks, canvasWidth, canvasHeight) {
                if (!document.getElementById('showMouth').checked) return;
                
                // Inner lip contour only
                const fullMouthIndices = [0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146, 61, 185, 40, 39, 37, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95, 78, 191, 80, 81, 82];
                
                // Use only the inner lip landmarks (indices 20-39)
                const mouthIndices = fullMouthIndices.slice(20, 40);
                console.log(mouthIndices.length);
                mouthIndices.splice(1, 10);
                console.log(mouthIndices.length);
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 3;
                
                this.ctx.beginPath();
                mouthIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.closePath();
                this.ctx.stroke();
            }
            
            drawNose(landmarks, canvasWidth, canvasHeight) {
                if (!document.getElementById('showNose').checked) return;
                
                // MediaPipe nose landmarks
                const noseIndices = [1, 2, 5, 4, 6, 19, 20, 94, 125, 141, 235, 236, 3, 51, 48, 115, 131, 134, 102, 49, 220, 305, 281, 360, 279];
                
                this.ctx.strokeStyle = '#ffe66d';
                this.ctx.lineWidth = 3;
                
                this.ctx.beginPath();
                noseIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.closePath();
                this.ctx.stroke();
            }
            
            drawEars(landmarks, canvasWidth, canvasHeight) {
                if (!document.getElementById('showEars').checked) return;
                
                // MediaPipe ear landmarks (approximate positions)
                // Note: MediaPipe doesn't have specific ear landmarks, so we'll use face contour points
                const leftEarIndices = [234, 93, 132, 58, 172, 136, 150, 149, 176, 148, 152, 377, 400, 378, 379, 365, 397, 288, 361, 323];
                const rightEarIndices = [454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93];
                
                this.ctx.strokeStyle = '#a8e6cf';
                this.ctx.lineWidth = 3;
                
                // Draw left ear area
                this.ctx.beginPath();
                leftEarIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
                
                // Draw right ear area
                this.ctx.beginPath();
                rightEarIndices.forEach((index, i) => {
                    const landmark = landmarks[index];
                    const x = landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
            }
            
            updateSettings() {
                // Settings are checked in draw methods
            }
            
            updateBlinkFrequency(frequency) {
                // Adjust blink intervals based on frequency (0-3)
                // Higher frequency = more frequent blinks
                const baseMin = 2000;
                const baseMax = 5000;
                
                this.minBlinkInterval = baseMin / frequency;
                this.maxBlinkInterval = baseMax / frequency;
            }
            
            // Cartoon Animation Methods
            animateCartoon(landmarks) {
                if (!landmarks || landmarks.length === 0) return;

                // Calculate face bounding box once per frame
                const faceBoundingBox = this.calculateFaceBoundingBox(landmarks);

                // Calculate yaw for head position offset
                const noseTip = landmarks[1];
                const headRotationSensitivity = parseFloat(document.getElementById('headRotation').value);
                const yaw = (noseTip.x - 0.5) * headRotationSensitivity * 30;
                this.currentYaw = yaw;

                const intensity = parseFloat(document.getElementById('animationIntensity').value);
                const eyeSensitivity = parseFloat(document.getElementById('eyeSensitivity').value);
                const mouthSensitivity = parseFloat(document.getElementById('mouthSensitivity').value);

                this.animateEyes(landmarks, faceBoundingBox, intensity * eyeSensitivity);
                this.animateMouth(landmarks, faceBoundingBox, intensity * mouthSensitivity);
                this.animateHeadRotation(landmarks, intensity * headRotationSensitivity);
            }

            drawDebugBoxes(faceBoundingBox) {
                // Clear previous debug visualization
                this.cartoonElements.debugLayer.innerHTML = '';

                // Draw target frame box (blue) - where features should be mapped to
                const targetBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                targetBox.setAttribute('x', this.targetFrame.x);
                targetBox.setAttribute('y', this.targetFrame.y);
                targetBox.setAttribute('width', this.targetFrame.width);
                targetBox.setAttribute('height', this.targetFrame.height);
                targetBox.setAttribute('fill', 'none');
                targetBox.setAttribute('stroke', 'blue');
                targetBox.setAttribute('stroke-width', '2');
                this.cartoonElements.debugLayer.appendChild(targetBox);

                // Draw original bounding box (red) - scaled to 400x400
                const originalBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                originalBox.setAttribute('x', faceBoundingBox.minX * 400);
                originalBox.setAttribute('y', faceBoundingBox.minY * 400);
                originalBox.setAttribute('width', faceBoundingBox.width * 400);
                originalBox.setAttribute('height', faceBoundingBox.height * 400);
                originalBox.setAttribute('fill', 'none');
                originalBox.setAttribute('stroke', 'red');
                originalBox.setAttribute('stroke-width', '2');
                this.cartoonElements.debugLayer.appendChild(originalBox);
            }
            
            animateEyes(landmarks, faceBoundingBox, sensitivity) {
                // Hardcode: Don't show eyes for face-9
                const currentFace = this.faceConfigs[this.currentFaceIndex];
                if (currentFace && currentFace.id === 'face-9') {
                    this.cartoonElements.leftEye.style.display = 'none';
                    this.cartoonElements.rightEye.style.display = 'none';
                    return;
                }

                // Make sure eyes are visible for other faces
                this.cartoonElements.leftEye.style.display = 'block';
                this.cartoonElements.rightEye.style.display = 'block';

                // Get eye landmarks
                const leftEyeCenter = this.getEyeCenter(landmarks, 'left');
                const rightEyeCenter = this.getEyeCenter(landmarks, 'right');

                if (leftEyeCenter && rightEyeCenter) {
                    // Transform eye centers to target frame using bounding box
                    const leftTransformed = this.transformLandmarkToTargetFrame(leftEyeCenter, faceBoundingBox);
                    const rightTransformed = this.transformLandmarkToTargetFrame(rightEyeCenter, faceBoundingBox);

                    // Apply smoothing to prevent jittery movement
                    const smoothLeft = this.smoothPosition('leftEye', leftTransformed);
                    const smoothRight = this.smoothPosition('rightEye', rightTransformed);

                    // Handle blinking for both eyes together
                    this.updateEyeBlinking(smoothLeft, smoothRight);
                }
            }
            
            updateEyeBlinking(leftPosition, rightPosition) {
                const now = Date.now();
                const timer = this.blinkTimer;
                
                // Check if it's time to start a new blink
                if (!timer.isBlinking && now >= timer.nextBlink) {
                    timer.isBlinking = true;
                    timer.blinkStart = now;
                    // Randomly select a blink image for both eyes
                    const randomBlinkImage = this.blinkImages[Math.floor(Math.random() * this.blinkImages.length)];
                    this.cartoonElements.leftEye.setAttribute('href', randomBlinkImage);
                    this.cartoonElements.rightEye.setAttribute('href', randomBlinkImage);
                }
                
                // Check if blink should end
                if (timer.isBlinking && (now - timer.blinkStart) >= this.blinkDuration) {
                    timer.isBlinking = false;
                    // Schedule next blink
                    const randomInterval = this.minBlinkInterval + 
                        Math.random() * (this.maxBlinkInterval - this.minBlinkInterval);
                    timer.nextBlink = now + randomInterval;
                    // Return both eyes to normal images
                    this.cartoonElements.leftEye.setAttribute('href', 'eye-left.png');
                    this.cartoonElements.rightEye.setAttribute('href', 'eye-right.png');
                }
                
                // Update eye positions with 50% increased horizontal distance
                const centerX = (leftPosition.x + rightPosition.x) / 2;
                const eyeSpacingScale = 1.5; // Increase distance by 50%

                const scaledLeftX = centerX - (centerX - leftPosition.x) * eyeSpacingScale;
                const scaledRightX = centerX + (rightPosition.x - centerX) * eyeSpacingScale;

                // Apply horizontal offset based on yaw if yaw < 0
                const yawOffset = this.currentYaw < 0 ? this.currentYaw * 10 : 0;

                // Align eyes vertically by using average y position
                const alignedY = (leftPosition.y + rightPosition.y) / 2;

                this.cartoonElements.leftEye.setAttribute('x', scaledLeftX - 15 + yawOffset);
                this.cartoonElements.leftEye.setAttribute('y', alignedY - 15);
                this.cartoonElements.rightEye.setAttribute('x', scaledRightX - 15 + yawOffset);
                this.cartoonElements.rightEye.setAttribute('y', alignedY - 15);
            }
            
            animateMouth(landmarks, faceBoundingBox, sensitivity) {
                // Hardcode: Don't show mouth for faces 7 and 8
                const currentFace = this.faceConfigs[this.currentFaceIndex];
                if (currentFace && (currentFace.id === 'face-7' || currentFace.id === 'face-8')) {
                    this.cartoonElements.mouthLayer.innerHTML = '';
                    this.cartoonElements.smileImage.style.display = 'none';
                    return;
                }

                // Debug: Log wrapper and SVG dimensions on first mouth animation
                if (!this.loggedWrapperDimensions) {
                    const wrapper = document.getElementById('cartoon-wrapper');
                    const svg = document.getElementById('cartoon-svg');
                    console.log('Wrapper dimensions:', wrapper.offsetWidth, 'x', wrapper.offsetHeight);
                    console.log('SVG dimensions:', svg.offsetWidth, 'x', svg.offsetHeight);
                    console.log('Target frame:', this.targetFrame);
                    console.log('Face position:', {left: this.faceLeft, top: this.faceTop, scale: this.faceScale});
                    this.loggedWrapperDimensions = true;
                }

                // Use MediaPipe's inner lip landmarks for better accuracy
                // These are the specific landmarks for the inner lip contour
                const fullMouthIndices = [0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146, 61, 185, 40, 39, 37, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95, 78, 191, 80, 81, 82];

                // Use only the inner lip landmarks (indices 20-39)
                const mouthIndices = fullMouthIndices.slice(20, 40);

                // Detect if mouth is closed by measuring vertical distance between upper and lower lips
                // Upper lip center: landmark 13
                // Lower lip center: landmark 14
                const upperLip = landmarks[13];
                const lowerLip = landmarks[14];
                const mouthOpenDistance = Math.abs(lowerLip.y - upperLip.y);

                // Threshold for closed mouth (normalized coordinates)
                // Use stricter threshold to only detect truly closed mouths
                const closedMouthThreshold = 0.01;
                const isMouthClosed = mouthOpenDistance < closedMouthThreshold;

                const now = Date.now();
                const timer = this.mouthClosedTimer;

                // Track mouth closed duration
                if (isMouthClosed) {
                    // Start timer if mouth just closed
                    if (timer.closedStartTime === null) {
                        timer.closedStartTime = now;
                    }

                    // Check if mouth has been closed long enough to show smile
                    const closedDuration = now - timer.closedStartTime;
                    if (closedDuration >= this.mouthClosedDelay && !timer.isShowingSmile) {
                        timer.isShowingSmile = true;
                    }
                } else {
                    // Mouth is open - reset timer and hide smile
                    timer.closedStartTime = null;
                    if (timer.isShowingSmile) {
                        timer.isShowingSmile = false;
                        this.cartoonElements.smileImage.style.display = 'none';
                    }
                }

                // First pass: transform all landmarks and calculate center
                const transformedPoints = [];
                let centerX = 0, centerY = 0;

                mouthIndices.forEach((index) => {
                    const landmark = landmarks[index];
                    const transformed = this.transformLandmarkToTargetFrame(landmark, faceBoundingBox);
                    transformedPoints.push(transformed);
                    centerX += transformed.x;
                    centerY += transformed.y;
                });

                centerX /= transformedPoints.length;
                centerY /= transformedPoints.length;

                // Apply smoothing to mouth center position
                const smoothedMouthCenter = this.smoothPosition('mouthCenter', { x: centerX, y: centerY });

                // Apply horizontal offset based on yaw if yaw < 0
                const yawOffset = this.currentYaw < 0 ? this.currentYaw * 10 : 0;

                // Show smile image or mouth outline based on state
                if (timer.isShowingSmile) {
                    // Hide mouth outline and show smile image centered at mouth position
                    this.cartoonElements.mouthLayer.innerHTML = '';

                    // Scale smile image by the same factor as the background image
                    const baseSmileSize = 80;
                    const smileWidth = baseSmileSize * this.imageScale;
                    const smileHeight = baseSmileSize * this.imageScale;
                    const smileX = smoothedMouthCenter.x - smileWidth / 2 + yawOffset;

                    // Adjust Y position for face-9 (move down by 12pts)
                    let smileY = smoothedMouthCenter.y - smileHeight / 2;
                    if (currentFace && currentFace.id === 'face-9') {
                        smileY += 12;
                    }

                    // Debug: Log smile positioning on first show
                    if (!this.loggedSmilePosition) {
                        console.log('Smile positioning:', {
                            mouthCenter: smoothedMouthCenter,
                            imageScale: this.imageScale,
                            smileSize: smileWidth + 'x' + smileHeight,
                            position: {x: smileX, y: smileY}
                        });
                        this.loggedSmilePosition = true;
                    }

                    this.cartoonElements.smileImage.setAttribute('width', smileWidth);
                    this.cartoonElements.smileImage.setAttribute('height', smileHeight);
                    this.cartoonElements.smileImage.setAttribute('x', smileX);
                    this.cartoonElements.smileImage.setAttribute('y', smileY);
                    this.cartoonElements.smileImage.style.display = 'block';

                    // Re-append smile image to ensure it's in the DOM
                    this.cartoonElements.mouthLayer.appendChild(this.cartoonElements.smileImage);
                } else {
                    // Show mouth outline
                    this.cartoonElements.smileImage.style.display = 'none';
                    this.cartoonElements.mouthLayer.innerHTML = '';

                    // Second pass: scale points by 3x relative to center and apply yaw offset
                    const mouthScale = 3.0;
                    // Adjust Y position for face-9 (move down by 12pts)
                    const yAdjustment = (currentFace && currentFace.id === 'face-9') ? 12 : 0;
                    const scaledPoints = transformedPoints.map(point => ({
                        x: centerX + (point.x - centerX) * mouthScale + yawOffset,
                        y: centerY + (point.y - centerY) * mouthScale + yAdjustment
                    }));

                    // Create mouth path using scaled landmarks
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('stroke', '#333');
                    path.setAttribute('stroke-width', '4');
                    path.setAttribute('fill', 'none');

                    let pathData = '';
                    scaledPoints.forEach((point, i) => {
                        if (i === 0) {
                            pathData += `M${point.x} ${point.y}`;
                        } else {
                            pathData += ` L${point.x} ${point.y}`;
                        }
                    });
                    pathData += ' Z'; // Close the path

                    path.setAttribute('d', pathData);
                    this.cartoonElements.mouthLayer.appendChild(path);
                }

                // Store mouth closed state for use by other methods
                this.isMouthClosed = isMouthClosed;
            }
            
            animateHeadRotation(landmarks, sensitivity) {
                // Calculate head rotation using key facial landmarks
                const noseTip = landmarks[1];
                const leftEye = landmarks[33];
                const rightEye = landmarks[362];

                if (noseTip && leftEye && rightEye) {
                    // Calculate yaw (left/right head turn)
                    const yaw = (noseTip.x - 0.5) * sensitivity * 30; // -30 to +30 degrees

                    // Calculate pitch (up/down head tilt)
                    const pitch = (noseTip.y - 0.5) * sensitivity * 15; // -15 to +15 degrees

                    // Display yaw value for debugging
                    document.getElementById('debug-yaw').textContent = `Yaw: ${yaw.toFixed(2)} | noseTip.x: ${noseTip.x.toFixed(3)}`;

                    // Apply rotation to the entire cartoon
                    const cartoonSvg = document.getElementById('cartoon-svg');
                    cartoonSvg.style.transform = `rotateY(${yaw}deg) rotateX(${pitch}deg)`;
                    cartoonSvg.style.transformOrigin = 'center center';

                    // Flip the background PNG based on head turn
                    // Simpler approach: use transform-origin to control flip anchor point
                    const backgroundImg = document.getElementById('cartoon-bg');
                    const shouldFlip = yaw < -1;

                    if (shouldFlip) {
                        // Turned left - flip horizontally around the center
                        backgroundImg.style.transform = 'scaleX(-1)';
                        backgroundImg.style.transformOrigin = 'center center';
                    } else {
                        // Normal orientation
                        backgroundImg.style.transform = 'scaleX(1)';
                        backgroundImg.style.transformOrigin = 'center center';
                    }
                }
            }
            
            getEyeCenter(landmarks, side) {
                const eyeIndices = side === 'left' 
                    ? [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
                    : [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
                
                let sumX = 0, sumY = 0;
                let count = 0;
                
                eyeIndices.forEach(index => {
                    if (landmarks[index]) {
                        sumX += landmarks[index].x;
                        sumY += landmarks[index].y;
                        count++;
                    }
                });
                
                return count > 0 ? { x: sumX / count, y: sumY / count } : null;
            }
            
            getFaceCenter(landmarks) {
                // Use nose tip as face center
                const noseTip = landmarks[1];
                return noseTip ? { x: noseTip.x, y: noseTip.y } : { x: 0.5, y: 0.5 };
            }
            
            smoothPosition(key, newPosition) {
                if (!this.lastPositions[key]) {
                    this.lastPositions[key] = newPosition;
                    return newPosition;
                }

                const lastPos = this.lastPositions[key];
                const smoothed = {
                    x: lastPos.x + (newPosition.x - lastPos.x) * this.smoothingFactor,
                    y: lastPos.y + (newPosition.y - lastPos.y) * this.smoothingFactor
                };

                this.lastPositions[key] = smoothed;
                return smoothed;
            }

            calculateFaceBoundingBox(landmarks) {
                // Find min/max coordinates across all landmarks
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                landmarks.forEach(landmark => {
                    if (landmark.x < minX) minX = landmark.x;
                    if (landmark.x > maxX) maxX = landmark.x;
                    if (landmark.y < minY) minY = landmark.y;
                    if (landmark.y > maxY) maxY = landmark.y;
                });

                return {
                    minX,
                    minY,
                    maxX,
                    maxY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            transformLandmarkToTargetFrame(landmark, faceBoundingBox) {
                // Calculate scale factor to fit face into target frame while preserving aspect ratio
                const scaleX = this.targetFrame.width / faceBoundingBox.width;
                const scaleY = this.targetFrame.height / faceBoundingBox.height;

                // Use smaller scale to preserve aspect ratio
                const scale = Math.min(scaleX, scaleY);

                // Calculate scaled dimensions
                const scaledWidth = faceBoundingBox.width * scale;
                const scaledHeight = faceBoundingBox.height * scale;

                // Calculate offsets to center the face in the target frame
                const offsetX = this.targetFrame.x + (this.targetFrame.width - scaledWidth) / 2;
                const offsetY = this.targetFrame.y + (this.targetFrame.height - scaledHeight) / 2;

                // Transform the landmark from normalized coordinates to canvas coordinates
                const normalizedX = (landmark.x - faceBoundingBox.minX) / faceBoundingBox.width;
                const normalizedY = (landmark.y - faceBoundingBox.minY) / faceBoundingBox.height;

                return {
                    x: normalizedX * scaledWidth + offsetX,
                    y: normalizedY * scaledHeight + offsetY
                };
            }
        }
        
        // Initialize the face tracker when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const tracker = new FaceTracker();
            // Auto-start the camera
            setTimeout(() => tracker.start(), 500);
        });
    </script>
</body>
</html>
